<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Data_Wrangling_Lesson_2</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
  body {
    padding: 2cm; 
  }
}
</style>


</head>

<body>

<h2 id="toc_0">File Descriptors</h2>

<p>A <strong>file descriptor</strong> is a non-negative integer that serves as an abstract indicator for accessing a file or other input/output resources, such as pipes. When a program is executed, the operating system assigns it three standard file descriptors by default (0,1,2).</p>

<h2 id="toc_1">Linux Standard Streams</h2>

<p>In Linux (and Unix-based systems), <strong>standard streams</strong> are the channels through which input and output flow. These streams provide a mechanism to interact with processes via input, output, and error handling. There are three main standard streams:</p>

<ul>
<li><strong>Standard Input (stdin)</strong></li>
<li><strong>Standard Output (stdout)</strong></li>
<li><strong>Standard Error (stderr)</strong></li>
</ul>

<h3 id="toc_2">1. Standard Input (stdin)</h3>

<ul>
<li><strong>File Descriptor</strong>: 0</li>
<li><strong>Purpose</strong>: The standard input stream is used to provide input to a program. By default, this is the keyboard, but it can also be redirected from files or other processes.</li>
<li><strong>Common Usage</strong>: Inputting text into commands that require user interaction or redirection from a file.</li>
</ul>

<h3 id="toc_3">Example: Using <code>cat</code> with Standard Input (stdin)</h3>

<div><pre><code class="language-bash">cat</code></pre></div>

<p>In this case, the <code>cat</code> command waits for input from stdin. You can type some text and hit Enter. To end the input, press Ctrl+D.</p>

<h3 id="toc_4"><strong>Using cut</strong></h3>

<p>The <code>cut</code> command is used to extract sections from each line of files.</p>

<h3 id="toc_5"><strong>Example: Extract the first field (column) from a file</strong></h3>

<div><pre><code class="language-bash">cut -d &#39;,&#39; -f 2 data.csv   # Extract the second field using a comma as delimiter</code></pre></div>

<p><strong>More</strong> <code>cut</code> <strong>options</strong></p>

<table>
<thead>
<tr>
<th><strong>Option</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-f</code></td>
<td>Specify fields (columns) to extract, separated by a delimiter.</td>
<td><code>cut -f 1,3 file.txt</code> (extract fields 1 and 3)</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>Specify the delimiter that separates fields (default is tab).</td>
<td><code>cut -d &#39;,&#39; -f 2 file.csv</code> (comma-separated values)</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>Extract specific character positions.</td>
<td><code>cut -c 1-5 file.txt</code> (extract characters 1 to 5)</td>
</tr>
<tr>
<td><code>--complement</code></td>
<td>Extract everything <strong>except</strong> the specified fields or characters.</td>
<td><code>cut -f 1 --complement file.txt</code></td>
</tr>
<tr>
<td><code>-b</code></td>
<td>Extract specific byte positions.</td>
<td><code>cut -b 1-3 file.txt</code> (extract first 3 bytes)</td>
</tr>
<tr>
<td><code>--output-delimiter</code></td>
<td>Change the output delimiter when displaying fields.</td>
<td><code>cut -f 1,3 -d &#39;,&#39; --output-delimiter=&#39;|&#39; file.csv</code></td>
</tr>
<tr>
<td><code>--help</code></td>
<td>Display help information about the <code>cut</code> command.</td>
<td><code>cut --help</code></td>
</tr>
<tr>
<td><code>--version</code></td>
<td>Display the version of the <code>cut</code> command.</td>
<td><code>cut --version</code></td>
</tr>
</tbody>
</table>

<h3 id="toc_6"><strong>Using find</strong></h3>

<p>The <code>find</code> command searches for files and directories in a directory hierarchy.</p>

<h3 id="toc_7">Example: Find all .txt files in the current directory</h3>

<div><pre><code class="language-bash">find . -name &quot;*.txt&quot;</code></pre></div>

<p><code>.</code>: Specifies the current directory as the starting point.
<code>-name &quot;*.txt&quot;</code>: Looks for files with the <code>.txt</code> extension.
This command will list all <code>.txt</code> files in the current directory and its subdirectories.</p>

<p><strong>More</strong> <code>find</code> <strong>options</strong></p>

<table>
<thead>
<tr>
<th><strong>Option</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-name PATTERN</code></td>
<td>Find files with a name matching the given pattern.</td>
<td><code>find . -name &quot;*.txt&quot;</code></td>
</tr>
<tr>
<td><code>-type TYPE</code></td>
<td>Find files of a specific type (e.g., <code>f</code> for files, <code>d</code> for directories).</td>
<td><code>find . -type f</code> (find files)</td>
</tr>
<tr>
<td><code>-size N[c]</code></td>
<td>Find files of a specific size (e.g., <code>-size 100c</code> for 100 bytes).</td>
<td><code>find . -size +100M</code> (files larger than 100MB)</td>
</tr>
<tr>
<td><code>-mtime N</code></td>
<td>Find files modified N days ago (e.g., <code>-mtime +30</code> for files modified 30 days ago).</td>
<td><code>find . -mtime -7</code> (modified in the last week)</td>
</tr>
<tr>
<td><code>-ctime N</code></td>
<td>Find files with their status changed N days ago.</td>
<td><code>find . -ctime 1</code> (changed exactly 1 day ago)</td>
</tr>
<tr>
<td><code>-atime N</code></td>
<td>Find files accessed N days ago.</td>
<td><code>find . -atime +30</code> (not accessed in 30+ days)</td>
</tr>
<tr>
<td><code>-user USER</code></td>
<td>Find files owned by a specific user.</td>
<td><code>find /home -user john</code></td>
</tr>
<tr>
<td><code>-group GROUP</code></td>
<td>Find files belonging to a specific group.</td>
<td><code>find /project -group developers</code></td>
</tr>
<tr>
<td><code>-perm MODE</code></td>
<td>Find files with specific permissions.</td>
<td><code>find . -perm 755</code></td>
</tr>
<tr>
<td><code>-exec COMMAND {} \;</code></td>
<td>Execute a command on each found file.</td>
<td><code>find . -name &quot;*.log&quot; -exec rm {} \;</code></td>
</tr>
<tr>
<td><code>-print</code></td>
<td>Print the names of the found files.</td>
<td><code>find . -name &quot;*.sh&quot; -print</code></td>
</tr>
<tr>
<td><code>-ls</code></td>
<td>Print a long listing of the found files.</td>
<td><code>find . -ls</code></td>
</tr>
</tbody>
</table>

<h3 id="toc_8"><strong>Using paste</strong></h3>

<p>The <code>paste</code> command is used to merge lines of files.</p>

<h3 id="toc_9">Example: Combine two files side by side</h3>

<div><pre><code class="language-bash">paste file1.txt file2.txt</code></pre></div>

<p>This command merges <code>file1.txt</code> and <code>file2.txt</code>, displaying their contents side by side, with a tab separating the columns.</p>

<p><strong>More</strong> <code>paste</code> <strong>options</strong></p>

<table>
<thead>
<tr>
<th><strong>Option</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-d</code></td>
<td>Specify a delimiter to use between pasted lines.</td>
<td><code>paste -d &#39;,&#39; file1.txt file2.txt</code> (use comma as delimiter)</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>Paste one file at a time, instead of parallel line-by-line.</td>
<td><code>paste -s file1.txt</code> (concatenate lines from file1)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Use standard input as one of the input files.</td>
<td><code>paste - file1.txt</code> (paste stdin with file1.txt)</td>
</tr>
<tr>
<td><code>--help</code></td>
<td>Display help information about the <code>paste</code> command.</td>
<td><code>paste --help</code></td>
</tr>
<tr>
<td><code>--version</code></td>
<td>Display the version of the <code>paste</code> command.</td>
<td><code>paste --version</code></td>
</tr>
</tbody>
</table>

<h3 id="toc_10"><strong>Using sort</strong></h3>

<p>The <code>sort</code>command arranges in several ways</p>

<h3 id="toc_11">Example: Sort by a Specific Field</h3>

<div><pre><code class="language-bash">sort -k 2 filename.txt</code></pre></div>

<p>This sorts by the second field of each line</p>

<p><strong>More</strong> <code>sort</code> <strong>options</strong></p>

<table>
<thead>
<tr>
<th><strong>Option</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-n</code></td>
<td>Sort numerically (e.g., 1, 2, 10 instead of 1, 10, 2).</td>
<td><code>sort -n file.txt</code></td>
</tr>
<tr>
<td><code>-r</code></td>
<td>Sort in reverse order.</td>
<td><code>sort -r file.txt</code></td>
</tr>
<tr>
<td><code>-k N</code></td>
<td>Sort based on the Nth column or field.</td>
<td><code>sort -k 2 file.txt</code> (sort by 2nd column)</td>
</tr>
<tr>
<td><code>-t CHAR</code></td>
<td>Specify the field delimiter (default is whitespace).</td>
<td><code>sort -t &#39;,&#39; -k 2 file.csv</code> (comma-separated values)</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>Sort and remove duplicate lines.</td>
<td><code>sort -u file.txt</code></td>
</tr>
<tr>
<td><code>-o FILE</code></td>
<td>Write the output to the specified file instead of standard output.</td>
<td><code>sort file.txt -o sorted_file.txt</code></td>
</tr>
<tr>
<td><code>-b</code></td>
<td>Ignore leading blanks when sorting.</td>
<td><code>sort -b file.txt</code></td>
</tr>
<tr>
<td><code>-f</code></td>
<td>Ignore case when sorting (case-insensitive sort).</td>
<td><code>sort -f file.txt</code></td>
</tr>
<tr>
<td><code>-M</code></td>
<td>Sort by month (e.g., Jan, Feb, Mar).</td>
<td><code>sort -M file.txt</code></td>
</tr>
<tr>
<td><code>--version</code></td>
<td>Display the version of the <code>sort</code> command.</td>
<td><code>sort --version</code></td>
</tr>
<tr>
<td><code>-h</code></td>
<td>Sort numbers in human-readable format (e.g., 1K, 2M).</td>
<td><code>sort -h file.txt</code></td>
</tr>
<tr>
<td><code>--parallel=N</code></td>
<td>Specify the number of sorts to run in parallel.</td>
<td><code>sort --parallel=4 file.txt</code></td>
</tr>
<tr>
<td><code>--check</code></td>
<td>Check whether the input is sorted without modifying it.</td>
<td><code>sort --check file.txt</code></td>
</tr>
</tbody>
</table>

<h3 id="toc_12">Example: Redirecting stdin to a file</h3>

<div><pre><code class="language-bash">cat &gt; output.txt</code></pre></div>

<p>This command takes input from stdin and saves it into the file <code>output.txt</code>.</p>

<h3 id="toc_13">Example: Redirecting stdin from a file</h3>

<div><pre><code class="language-bash">cat &lt; input.txt</code></pre></div>

<p>This command reads from the file <code>input.txt</code> and passes its content as stdin to the <code>cat</code> command.</p>

<h3 id="toc_14">2. Standard Output (stdout)</h3>

<ul>
<li><strong>File Descriptor:</strong> 1</li>
<li><strong>Purpose:</strong> The standard output stream is used to output the result of a command. By default, it prints to the terminal, but it can be redirected to files or other processes.</li>
<li><strong>Common Usage:</strong> Displaying the results of commands in the terminal or redirecting the output to files.</li>
</ul>

<h3 id="toc_15">Example:</h3>

<div><pre><code class="language-bash">echo &quot;Hello, World!&quot;</code></pre></div>

<p>This command sends the string <code>Hello, World!</code> to <code>stdout</code>, which by default prints it to the terminal.</p>

<p><strong>Redirecting</strong> <code>stdout</code> <strong>to a file:</strong></p>

<div><pre><code class="language-bash">ls &gt; directory_listing.txt</code></pre></div>

<p>This command redirects the output of <code>ls</code> (which lists files and directories) to the file <code>directory_listing.txt</code> instead of displaying it in the terminal.</p>

<h3 id="toc_16">3. Standard Error (stderr)</h3>

<ul>
<li><strong>File Descriptor:</strong> 2</li>
<li>P<strong>urpose:</strong> The standard error stream is used to output error messages. Like <code>stdout</code>, it prints to the terminal by default but can also be redirected.</li>
<li><strong>Common Usage:</strong> Displaying error messages from commands.</li>
</ul>

<h3 id="toc_17">Example:</h3>

<p>The above command will try to list a file that doesnâ€™t exist, so the error message will be sent to stderr and printed on the terminal.</p>

<p><strong>Redirecting</strong> <code>stderr</code> <strong>to a file:</strong></p>

<div><pre><code class="language-bash">ls nonexistentfile 2&gt; error.log</code></pre></div>

<p>This command redirects the error message from stderr to a file named <code>error.log</code></p>

<h2 id="toc_18">Combining Standard Output and Error Streams</h2>

<p>Sometimes, you may want to capture both stdout and stderr in the same file.</p>

<p><strong>Example:</strong></p>

<div><pre><code class="language-bash">ls validfile nonexistentfile &gt; output.log 2&gt;&amp;1</code></pre></div>

<ul>
<li><code>&gt; output.log</code>: Redirects <code>stdout</code> to <code>output.log</code></li>
<li><code>2&gt;&amp;1</code>: Redirects <code>stderr</code> to wherever <code>stdout</code> is being redirected (in this case, to <code>output.log</code>).</li>
</ul>

<p>The <code>&amp;</code> symbol indicates that what follows (in this case, 1) is a <strong>file descriptor</strong>, not a file name. It tells the shell to redirect file descriptor <strong>2</strong> (<code>stderr</code>) to the same destination as file descriptor <strong>1</strong> (<code>stdout</code>). </p>

<ul>
<li>First, it redirects standard output (<code>stdout</code>) to output.log (the &gt; operator)</li>
<li>Then, it redirects standard error (<code>stderr</code>) to the same place that standard output is currently going (which is now o<code>utput.log</code> due to the earlier redirection).</li>
</ul>

<p>This allows to capture both the normal output and error messages of a command into the same destination, which can be very useful for debugging or logging purposes.</p>

<h3 id="toc_19">Summary of Redirection Operators</h3>

<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>&gt;</code></td>
<td>Redirects stdout to a file (overwrites the file).</td>
<td><code>command &gt; output.txt</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Redirects stdout to a file (appends to the file).</td>
<td><code>command &gt;&gt; output.txt</code></td>
</tr>
<tr>
<td><code>2&gt;</code></td>
<td>Redirects stderr to a file.</td>
<td><code>command 2&gt; error.log</code></td>
</tr>
<tr>
<td><code>2&gt;&amp;1</code></td>
<td>Redirects stderr to stdout.</td>
<td><code>command &gt; output.log 2&gt;&amp;1</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Redirects stdin from a file.</td>
<td><code>command &lt; input.txt</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_20">Creating and Editing Files With nano?</h2>

<p><code>nano</code> is a simple, user-friendly command-line text editor in Linux. It&#39;s used to create and edit text files directly from the terminal. It provides basic functionalities like creating, editing, saving, and navigating through files. Unlike more complex editors like <code>vim</code> or <code>emacs</code>, <code>nano</code> is intuitive and easy to use, making it ideal for beginners.</p>

<p><img align="right" width="900" height="300
00" src="https://github.com/JAGalarza/Data-Wrangling/blob/main/Images/nano.png?raw=true alt="Linux Manual"/></p>

<p>To create a new file or open an existing file with nano, simply use the following command:</p>

<div><pre><code class="language-bash">nano filename.txt</code></pre></div>

<p>This command opens the <code>filename.txt</code> in the nano editor, or creates it if it doesn&#39;t exist. Inside nano, you can type text, navigate through the file using arrow keys, and use basic keyboard shortcuts for operations like saving or exiting.</p>

<p>Type the following text inside the editor:</p>

<div><pre><code class="language-bash">Hello! This is a sample text file created using the nano editor.</code></pre></div>

<p>Save the file by pressing:</p>

<ul>
<li><code>Ctrl + O</code> (to write out the file)
Hit Enter to confirm the filename.</li>
</ul>

<p>Exit nano by pressing:</p>

<ul>
<li><code>Ctrl + X</code></li>
</ul>

<p>Write configuration settings inside a file named <code>conf.txt</code>:</p>

<div><pre><code class="language-bash">user=johndoe
password=12345
timeout=30</code></pre></div>

<p>Then save and exit (<code>Ctrl + O</code> and <code>Ctrl + X</code>).</p>

<h2 id="toc_21">Piping Standard Streams</h2>

<p><img align="right" width="900" height="300
00" src="https://github.com/JAGalarza/Data-Wrangling/blob/main/Images/pipes.png?raw=true alt="Linux Manual"/></p>

<p>Linux allows you to connect the output of one command to the input of another using pipes (<code>|</code>).</p>

<h3 id="toc_22">Pipes in Linux (<code>|</code>)</h3>

<p>In Linux, pipes (represented by the vertical bar (<code>|</code>) allow the output of one command to become the input for another command. This mechanism is fundamental in Unix-like systems, enabling to chain multiple commands together to perform complex tasks. The output from the first command is passed as input to the second command without needing to write to a file temporarily.</p>

<h3 id="toc_23">How Pipes Work</h3>

<p>In the syntax <code>command1</code> | <code>command2</code>, the output of <code>command1</code> (<code>stdout</code>) is &quot;piped&quot; into <code>command2</code> as its input (<code>stdin</code>). This chain can extend to multiple commands, like <code>command1</code> | <code>command2</code> | <code>command3</code>, where the output of each command is fed into the next one.</p>

<h3 id="toc_24">Basic Commands to Use with Pipes</h3>

<p>Two common commands frequently used with pipes are <code>cat</code> and <code>echo</code>.</p>

<h4 id="toc_25">The <code>cat</code> command: Concatenate and Display File Content</h4>

<p>This command reads files sequentially, concatenates them, and prints their content to standard output.</p>

<p><strong>Example:</strong></p>

<div><pre><code class="language-bash">cat conf.txt | grep &quot;word&quot;</code></pre></div>

<p>This command will take the content of <code>conf.txt</code> and pass it to <code>grep</code>, which searches for &quot;word&quot; in the file.</p>

<h3 id="toc_26">Display a Line of Text</h3>

<p><strong>Example:</strong></p>

<p>The echo command prints its arguments to the standard output.</p>

<div><pre><code class="language-bash">echo &quot;hello world&quot; | tr &#39;a-z&#39; &#39;A-Z&#39;</code></pre></div>

<p>This will pass the string &quot;hello world&quot; to the <code>tr</code> command, which translates the lowercase letters to uppercase.</p>

<p><strong>Example:</strong></p>

<h3 id="toc_27">The <code>head</code> and <code>tail</code> commands: Display First/Last Lines</h3>

<p>The <code>head</code> command shows the first few lines of a file, while <code>tail</code> shows the last few lines.</p>

<div><pre><code class="language-bash">cat file.txt | head -n 10</code></pre></div>

<p>This displays the first 10 lines of file.txt.</p>

<div><pre><code class="language-bash">echo &quot;Linux is powerful&quot; | wc -w</code></pre></div>

<p>This command will echo the string &quot;Linux is powerful&quot; and pipe it to <code>wc -w</code>, which counts the number of words. In this case, the output will be <code>3</code>.</p>

<h3 id="toc_28">The <code>wc</code> Command in Linux</h3>

<p>The <code>wc</code> command stands for &quot;word count&quot; and is used to count the number of lines, words, and bytes in files or from standard input. It can also count characters or the length of the longest line. </p>

<h4 id="toc_29">Basic Syntax:</h4>

<div><pre><code class="language-bash">wc [OPTION]... [FILE]...</code></pre></div>

<table>
<thead>
<tr>
<th>Option</th>
<th>Purpose</th>
<th>Example</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>-l</code></td>
<td>Count lines</td>
<td><code>wc -l myfile.txt</code></td>
</tr>
<tr>
<td><code>-w</code></td>
<td>Count words</td>
<td><code>wc -w myfile.txt</code></td>
</tr>
<tr>
<td><code>-c</code></td>
<td>Count bytes</td>
<td><code>wc -c myfile.txt</code></td>
</tr>
<tr>
<td><code>-m</code></td>
<td>Count characters</td>
<td><code>wc -m myfile.txt</code></td>
</tr>
<tr>
<td><code>-L</code></td>
<td>Display the length of the longest line</td>
<td><code>wc -L myfile.txt</code></td>
</tr>
</tbody>
</table>

<h3 id="toc_30">Piping Commands</h3>

<div><pre><code class="language-bash">cat myfile.txt | grep &quot;error&quot; | wc -l | head -n 1</code></pre></div>

<p>This pipeline finds and counts the lines containing the word &quot;error&quot; in <code>myfile.txt</code> and shows the first result</p>

<h2 id="toc_31">Combining Pipes and Redirection</h2>

<p><img align="right" width="900" height="200
00" src="https://github.com/JAGalarza/Data-Wrangling/blob/main/Images/chain.jpg?raw=true alt="Linux Manual"/></p>

<h3 id="toc_32">Redirecting stdout of a pipe to a file and stderr to another file</h3>

<p><strong>Example:</strong></p>

<div><pre><code class="language-bash">cat file.txt | grep &quot;pattern&quot; | wc -l &gt; output.txt 2&gt; error.txt</code></pre></div>

<ul>
<li><code>cat file.txt</code>: Reads the contents of <code>file.txt</code>.</li>
<li><code>grep &quot;pattern&quot;</code>: Filters the lines that contain &quot;pattern&quot;.</li>
<li><code>wc -l</code>: Counts the number of lines that match the pattern.</li>
<li><code>&gt; output.txt</code>: Redirects the stdout (the line count) to <code>output.txt</code>.</li>
<li><code>2&gt; error.txt</code>: Redirects any stderr (errors, if the file doesn&#39;t exist, or permission issues) to <code>error.txt</code>.</li>
</ul>

<h2 id="toc_33">Redirecting stdout to one file and both stdout and stderr to another file</h2>

<p><strong>Example:</strong></p>

<div><pre><code class="language-bash">cat file.txt | grep &quot;pattern&quot; &gt; result.txt 2&gt;&amp;1 | wc -l &gt; line_count.txt</code></pre></div>

<ul>
<li><p>The first pipe <code>cat file.txt | grep &quot;pattern&quot; &gt; result.txt 2&gt;&amp;1</code> sends both stdout and stderr to <code>result.txt</code>.</p></li>
<li><p>The second part of the chain <code>wc -l</code> counts the lines from the <code>grep</code> result.</p></li>
<li><p><code>&gt; line_count.txt</code> writes the line count result to <code>line_count.txt</code>.</p></li>
</ul>

<h2 id="toc_34">Redirecting stdout to one file, stderr to another, and stdout and stderr together to the terminal</h2>

<p><strong>Example:</strong></p>

<div><pre><code class="language-none">cat file.txt | grep &quot;pattern&quot; &gt; output.txt 2&gt; error.txt | tee combined.txt</code></pre></div>

<ul>
<li><code>cat file.txt</code>: Reads the content of <code>file.txt</code>.</li>
<li><code>grep &quot;pattern&quot;</code>: Searches for lines containing &quot;pattern&quot;.</li>
<li><code>&gt; output.txt</code>: Redirects stdout to <code>output.txt</code>.</li>
<li><code>2&gt; error.txt</code>: Redirects stderr to <code>error.txt</code>.</li>
<li><code>| tee combined.txt</code>: Sends the output of the pipe (stdout) to both the terminal and <code>combined.txt</code>.</li>
</ul>




</body>

</html>
