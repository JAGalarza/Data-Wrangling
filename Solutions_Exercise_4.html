<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Solutions_Exercise_4</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
  body {
    padding: 2cm; 
  }
}
</style>


</head>

<body>

<p><strong>1 Linearize the FASTQ File merging every 4 lines into a single line</strong>.</p>

<p><code>paste - - - - &lt; R1.fastq &gt; linearized_sample.txt</code></p>

<p><code>paste - - - -</code> reads 4 lines at a time and merges them into a single line. This is useful because FASTQ files have 4-line blocks (ID, sequence, separator, and quality scores). `&gt; redirects the output to llinearized_fastq.txt, saving the result in a new file</p>

<p><strong>2 Sort the sequences in <code>linearized_sample.txt</code> alphabetically, transform them back to a 4-line fastq format</strong> <code>reformatted.fastq</code> <strong>and confirm that the sorting it worked.</strong></p>

<div><pre><code class="language-bash">sort -k 2,2 linearized_sample.txt</code></pre></div>

<p><code>sort -k 2,2</code> sorts the file based on the second field, which is the DNA sequence in the linearized FASTQ file. Sorting sequences alphabetically can help with sequence comparison or identifying duplicates.</p>

<p>To  transform the <code>linearized_sample.txt</code> back to 4-line format.</p>

<div><pre><code class="language-none">awk -F&#39;\t&#39; &#39;{print $1&quot;\n&quot;$2&quot;\n&quot;$3&quot;\n&quot;$4}&#39; linearized_sample.txt &gt; reformatted.fastq</code></pre></div>

<p><code>-F&#39;\t&#39;</code>: This tells awk that the input file is tab-separated.
<code>{print $1&quot;\n&quot;$2&quot;\n&quot;$3&quot;\n&quot;$4}</code>: For each line in the file, it prints the first field (<code>$1</code>), second field (<code>$2</code>), third field (<code>$3</code>), and fourth field (<code>$4</code>) each on a new line (<code>\n</code>).
<code>$1</code>: Sequence ID line (starting with <code>@</code>)
<code>$2</code>: The DNA sequence
<code>$3</code>: The separator line (<code>+</code>)
<code>$4</code>: The quality score string</p>

<p>To confirm that the sorting worked</p>

<div><pre><code class="language-none">paste &lt;(grep &quot;@ST&quot; pool_1_of_10_R1.fastq) &lt;(grep &quot;@ST&quot; reformatted.fastq)</code></pre></div>

<p><code>grep &quot;@ST&quot; R1.fastq</code>: This extracts the lines matching @ST from the first file.
<code>grep &quot;@ST&quot; reformatted.fastq</code>: This extracts the lines matching @ST from the second file.
<code>&lt;(...)</code>: This is process substitution, allowing the output of grep to be treated as input to paste without creating temporary files.
<code>paste</code>: Combines the output from both commands and displays them side by side, with the lines from the first file in one column and the lines from the second file in another column.</p>

<p><strong>3 Sort the quality scores in reverse (descending) order</strong></p>

<div><pre><code class="language-bash">sort -k 4,4r linearized_sample.txt</code></pre></div>

<p><code>-k 4,4r</code> sorts based on the fourth field (the quality scores), in reverse order (r). This helps identify sequences with the lowest or highest overall quality scores quickly.</p>

<p><strong>4 Extract the sequence ID and the corresponding sequence</strong></p>

<div><pre><code class="language-bash">cut -f 1,2 linearized_sample.txt</code></pre></div>

<p><code>cut -f 1,2</code> extracts only the first (sequence ID) and second (DNA sequence) fields, discarding the rest. This is useful for focusing on just the identifiers and sequences, without other information.</p>

<p><strong>5 Extract Sequence Identifiers and Quality Scores</strong></p>

<div><pre><code class="language-none">cut -f 1,4 linearized_sample.txt</code></pre></div>

<p><code>cut -f 1,4</code> extracts the first (sequence ID) and fourth (quality scores) fields, allowing us to examine the relationship between sequence IDs and their quality scores.</p>

<p><strong>6 Change the delimiter from a tab to a custom character, such as a comma</strong></p>

<div><pre><code class="language-none">cat linearized_sample.txt | tr &#39;\t&#39; &#39;,&#39;</code></pre></div>

<p><code>cat</code> displays the content of linearized_sample.txt.
<code>tr &#39;\t&#39; &#39;,&#39;</code> replaces each tab character (<code>\t</code>) with a comma, changing the delimiter for better readability or for compatibility with other tools.</p>

<p><strong>7 Only print sequences longer than 50 bases</strong></p>

<div><pre><code class="language-bash">awk &#39;length($2) &gt; 50&#39; linearized_sample.txt</code></pre></div>

<p><code>awk</code> checks the length of the second field (the sequence). If the sequence is longer than 50 characters, it prints the entire line. This helps filter out shorter sequences.</p>

<p><strong>8 Sort Based on Sequence Length</strong></p>

<div><pre><code class="language-none">awk &#39;{print length($2), $0}&#39; linearized_sample.txt | sort -n</code></pre></div>

<p><code>awk</code> prints the length of the second field (the sequence) followed by the entire line.
<code>sort -n</code> sorts the output numerically by the sequence length, helping to find the shortest and longest sequences in the dataset.</p>

<p><strong>9 Combine sequence IDs and quality scores into a single output</strong></p>

<div><pre><code class="language-none">cut -f 1 linearized_sample.txt &gt; ids.txt
cut -f 4 linearized_sample.txt &gt; qualities.txt
paste ids.txt qualities.txt</code></pre></div>

<p><code>cut -f 1</code> extracts the sequence identifiers and saves them to ids.txt.
<code>cut -f 4</code> extracts the quality scores and saves them to qualities.txt.
<code>paste ids.txt qualities.txt</code> combines the sequence IDs and quality scores side by side, allowing for easy comparison</p>

<p><strong>10 Count the total number of sequences in the FASTQ file</strong></p>

<div><pre><code class="language-none">wc -l sample.fastq | awk &#39;{print $1 / 4}&#39;</code></pre></div>

<p><code>wc -l</code> counts the number of lines in the FASTQ file.
<code>awk &#39;{print $1 / 4}&#39;</code> divides the line count by 4, as each sequence consists of 4 lines in the FASTQ format (sequence ID, sequence, separator, and quality scores)</p>

<p><strong>11 Replace Sequences Longer Than 100 Bases with &quot;N&quot;</strong></p>

<div><pre><code class="language-bash">awk &#39;length($2) &gt; 100 {$2 = gensub(/./, &quot;N&quot;, &quot;g&quot;, $2)}1&#39; linearized_sample.txt</code></pre></div>

<p><code>length($2) &gt; 100</code> checks if the second field (the sequence) is longer than 100 bases.
<code>gensub(/./, &quot;N&quot;, &quot;g&quot;, $2)</code> replaces every character in the sequence with &quot;N&quot;.
The modified sequence is printed, replacing long sequences with &quot;N&quot;s</p>

<p><strong>12 Find Sequences with no alphanumeric ASCII characters.</strong></p>

<div><pre><code class="language-bash">awk &#39;$4 ~ /[^A-Za-z0-9]/&#39; linearized_sample.txt</code></pre></div>

<p>This checks if the fourth field (quality scores) contains any character that isnâ€™t an alphanumeric (A-Za-z0-9). This can help flag sequences with potentially problematic quality scores</p>

<p><strong>13 Combine fields using a different delimiter, like a colon instead of a tab</strong></p>

<div><pre><code class="language-none">paste -d &#39;:&#39; &lt;(cut -f 1 linearized_sample.txt) &lt;(cut -f 2 linearized_sample.txt)</code></pre></div>

<p><code>cut -f 1</code> and <code>cut -f 2</code> extract the first (ID) and second (sequence) fields, respectively.
<code>paste -d &#39;:&#39;</code> combines these fields into a single line, using a colon (:) as the separator instead of the default tab</p>

<p><strong>14 Extract sequences that contain the nucleotide pattern ACTGGC</strong></p>

<div><pre><code class="language-none">awk &#39;$2 ~ /ACTGGC/&#39; linearized_sample.txt</code></pre></div>

<p>This command looks for sequences that contain the subsequence <code>ACTGGC</code> in the second field (the DNA sequence). It prints the lines where the pattern is found, useful for identifying specific motifs</p>

<p><strong>15 Sort the sequences based on the length of the quality scores</strong></p>

<div><pre><code class="language-none">awk &#39;{print length($4), $0}&#39; linearized_sample.txt | sort -n</code></pre></div>

<p><code>awk &#39;{print length($4), $0}&#39;</code> calculates the length of the quality score string (field 4) and prints it alongside the full line.
<code>sort -n</code> sorts the lines by the length of the quality scores numerically.</p>

<p><strong>16 Trim all Sequences to a 50bp Length</strong></p>

<p><code>substr($2, 1, 50)</code> trims the sequence (field 2) to the first 50 characters.
<code>substr($4, 1, 50)</code> trims the quality scores (field 4) to the same length.
This is useful when trimming sequences to a uniform length for downstream analysis</p>

<p><strong>17 Calculate GC Content in percentage</strong></p>

<div><pre><code class="language-none">awk &#39;{gc=gsub(/[GC]/,&quot;&quot;, $2); print (gc/length($2))*100 &quot;%&quot;, $1}&#39; linearized_sample.txt</code></pre></div>

<p><code>gsub(/[GC]/, &quot;&quot;, $2)</code> counts the number of G and C bases in the sequence (field 2).
<code>(gc/length($2))*100</code> calculates the percentage of G and C content in the sequence.
The result is printed alongside the sequence ID</p>

<p><strong>18 Replace all occurrences of As nucleotides with &quot;N&quot;</strong></p>

<div><pre><code class="language-bash">sed &#39;s/[AT]/N/g&#39; linearized_sample.txt</code></pre></div>

<p><code>sed &#39;s/[AT]/N/g&#39;</code> replaces all occurrences of &quot;A&quot; and &quot;T&quot; in the sequences with &quot;N&quot;. This is useful for masking parts of the sequences for specific analysis purposes</p>

<p><strong>19 Create a summary showing each sequence ID and its length</strong></p>

<div><pre><code class="language-bash">awk &#39;{print $1, length($2)}&#39; linearized_sample.txt</code></pre></div>

<p>This prints each sequence ID (field 1) and the length of its corresponding sequence (field 2), helping to create a summary of sequence lengths for analysis</p>

<p><strong>20 Replace the delimiter in the file with another character (e.g., pipe <code>|</code>).</strong></p>

<div><pre><code class="language-bash">sed &#39;s/\t/|/g&#39; linearized_sample.txt</code></pre></div>

<p>This replaces all tab characters (<code>\t</code>) in the file with pipe characters (<code>|</code>), which is sometimes required for integration with other systems that expect a different delimiter.</p>

<p><strong>21 Bonus: For tasks 2, 3, 7, 8, 14, 15, 16, and 18, transform the linearized_sample.txt back to 4-line format</strong> </p>

<div><pre><code class="language-none">awk -F&#39;\t&#39; &#39;{print $1&quot;\n&quot;$2&quot;\n&quot;$3&quot;\n&quot;$4}&#39; linearized_sample.txt &gt; reformatted.fastq</code></pre></div>

<p><code>-F&#39;\t&#39;</code>: This tells awk that the input file is tab-separated.
<code>{print $1&quot;\n&quot;$2&quot;\n&quot;$3&quot;\n&quot;$4}</code>: For each line in the file, it prints the first field (<code>$1</code>), second field (<code>$2</code>), third field (<code>$3</code>), and fourth field (<code>$4</code>) each on a new line (<code>\n</code>).
<code>$1</code>: Sequence ID line (starting with <code>@</code>)
<code>$2</code>: The DNA sequence
<code>$3</code>: The separator line (<code>+</code>)
<code>$4</code>: The quality score string</p>

<table>
<thead>
<tr>
<th><strong>Importance of GC Content</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>1. Thermal Stability</strong></td>
<td>Higher GC content increases the melting temperature (Tm), crucial for techniques like PCR and primer design.</td>
</tr>
<tr>
<td><strong>2. DNA Structure</strong></td>
<td>Influences the formation of secondary structures (e.g., hairpins), affecting DNA/RNA function and stability.</td>
</tr>
<tr>
<td><strong>3. Gene Expression</strong></td>
<td>Affects the binding affinity of transcription factors and regulatory elements, influencing gene transcription levels.</td>
</tr>
<tr>
<td><strong>4. Species Identification</strong></td>
<td>Different species may exhibit characteristic GC content ranges, aiding in species identification and classification.</td>
</tr>
<tr>
<td><strong>5. Mutation Rates</strong></td>
<td>GC-rich regions may have different mutation rates, providing insights into genomic stability and mutation hotspots.</td>
</tr>
<tr>
<td><strong>6. Genome Assembly</strong></td>
<td>Serves as a quality control measure; deviations from expected GC content can indicate contamination or errors.</td>
</tr>
<tr>
<td><strong>7. Phylogenetic Studies</strong></td>
<td>Analyzing GC content across species provides insights into evolutionary adaptations and relationships.</td>
</tr>
</tbody>
</table>




</body>

</html>
